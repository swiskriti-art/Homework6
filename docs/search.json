[
  {
    "objectID": "HW6.html",
    "href": "HW6.html",
    "title": "HW6",
    "section": "",
    "text": "Task 1 - Conceptual questions\n\nThe purpose of lapply() function is to apply a function to each element of the list. lapply is used to avoid using loops. The equivalent purrr function is map.\nlapply(X = my_list, FUN = cor, method = \"kendall\")\nTwo advantages of using purrr functions instead of the BaseR apply family are:\n\nWe can easily work with other tidyverse functions as it is consistent in terms of function arguments and return value.\nThere are more helper functions in purrr package that makes writing code easy.\n\nSide effect functions are functions that perform some effect from the data but doesn’t change the actual data like print, write_csv etc.\nWe can name a variable sd in a function and not cause conflict with sd function because when a function is executed R creates a temporary function environment with its variables which goes away after execution.\n\n\n\nTask 2 - Writing Functions\n\nFunction to get Root Mean Square Error (RMSE)\n\n\ngetRMSE &lt;- function(resp, pred, ...) {\n  rmse &lt;- sqrt(mean((resp - pred)^2, ...))\n}\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# Calling the getRMSE function with responses and predictions\nrmse &lt;- getRMSE(resp, pred)\nrmse\n\n[1] 0.9581677\n\n# Calculate RMSE without removing missing values\nresp[c(20, 15)] = NA_real_\nnaRMSE &lt;- getRMSE(resp, pred)\nnaRMSE\n\n[1] NA\n\n# Calculate RMSE by removing missing values\nremNARMSE &lt;- getRMSE(resp, pred, na.rm = TRUE)\nremNARMSE\n\n[1] 0.9505445\n\n\n\nFunction to get Mean Absolute Error (MAE)\n\n\ngetMAE &lt;- function (resp, pred,...) {\n mae &lt;- mean(abs(resp-pred),...)\n}\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# Calling the getMAE function with responses and predictions\nMAE &lt;- getMAE(resp, pred)\nMAE\n\n[1] 0.8155776\n\n# Calculate MAE without removing missing values\nresp[c(30, 55)] = NA_real_\nnaMAE &lt;- getMAE(resp, pred)\nnaMAE\n\n[1] NA\n\n# Calculate MAE by removing missing values\nremNAMAE &lt;- getMAE(resp, pred, na.rm = TRUE)\nremNAMAE\n\n[1] 0.810958\n\n\n\nCreating a wrapper function for RMSE and MAE to get prediction errors\n\n\ngetErrors &lt;- function(resp, pred, metric = \"both\", ...) {\n  if(!is.vector(resp) | !is.numeric(resp)) { \n    stop (\"resp should be numeric vector\")\n  }\n  if(!is.vector(pred) | !is.numeric(pred)) { \n    stop (\"pred should be numeric vector\")\n  }\n  rmse &lt;- getRMSE(resp, pred, ...)\n  mae &lt;- getMAE(resp, pred, ...)\n  if(metric == \"RMSE\") return (c(\"RMSE\" = rmse))\n  else if (metric == \"MAE\") return (c(\"MAE\" = mae))\n  else return(c(\"RMSE\" = rmse, \"MAE\" = mae))\n}  \n\nTesting wrapping function\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nErrors &lt;- getErrors(resp, pred)\nErrors\n\n     RMSE       MAE \n0.9581677 0.8155776 \n\nErrors &lt;- getErrors(resp, pred, metric = \"RMSE\")\nErrors\n\n     RMSE \n0.9581677 \n\nErrors &lt;- getErrors(resp, pred, metric = \"MAE\")\nErrors\n\n      MAE \n0.8155776 \n\n# Calculate getErrors without removing missing values\nresp[c(3, 65)] = NA_real_\nnaErrors &lt;- getErrors(resp, pred)\nnaErrors\n\nRMSE  MAE \n  NA   NA \n\n# Calculate getErrors by removing missing values\nremNAErrors &lt;- getErrors(resp, pred, na.rm = TRUE)\nremNAErrors\n\n     RMSE       MAE \n0.9558537 0.8114248 \n\n# Testing with non-numeric and non-vector data\n# Commenting out for render error\n# nonVecErrs &lt;- getErrors(data.frame(resp), list(pred))\n\nTesting getErrors with invalid data types\n\n# Commenting out for render to work\n# nonVecErrs &lt;- getErrors(resp, list(pred))\n\n\n# Commenting out for render to work\n# nonVecErrs &lt;- getErrors(data.frame(\"resp\"), list(c(\"pred\")))\n\n\n\nTask 3 - Practice with purrr\n\nlibrary (tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.2\n✔ ggplot2   4.0.0     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlm_fit1 &lt;- lm(Sepal.Length ~ Sepal.Width + Species, data = iris)\nprint(\"Using coef()\")\n\n[1] \"Using coef()\"\n\ncoef(lm_fit1)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\nprint(\"Using $\")\n\n[1] \"Using $\"\n\nlm_fit1 $coefficients\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\nprint(\"Using pluck\")\n\n[1] \"Using pluck\"\n\npluck(lm_fit1, \"coefficients\")\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n\nUsing map and pluck to pull out a list element\n\nlm_fit2 &lt;- lm(Sepal.Length ~ Sepal.Width, data = iris)\nlm_fit3 &lt;- lm(Sepal.Length ~ Petal.Width + Sepal.Width + Species, data = iris)\nlm_fit4 &lt;- lm(Sepal.Length ~ Petal.Width + Petal.Length + Sepal.Width + Species,\ndata = iris)\nfits &lt;- list(lm_fit1, lm_fit2, lm_fit3, lm_fit4)\nmap(fits, pluck, \"coefficients\")\n\n[[1]]\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n[[2]]\n(Intercept) Sepal.Width \n  6.5262226  -0.2233611 \n\n[[3]]\n      (Intercept)       Petal.Width       Sepal.Width Speciesversicolor \n        2.5210733         0.3715768         0.6982260         0.9881297 \n Speciesvirginica \n        1.2375878 \n\n[[4]]\n      (Intercept)       Petal.Width      Petal.Length       Sepal.Width \n        2.1712663        -0.3151552         0.8292439         0.4958889 \nSpeciesversicolor  Speciesvirginica \n       -0.7235620        -1.0234978 \n\nmap(fits, confint )\n\n[[1]]\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n[[2]]\n                2.5 %     97.5 %\n(Intercept)  5.579865 7.47258038\nSepal.Width -0.529820 0.08309785\n\n[[3]]\n                        2.5 %    97.5 %\n(Intercept)        1.74261803 3.2995285\nPetal.Width       -0.02042746 0.7635811\nSepal.Width        0.46205710 0.9343950\nSpeciesversicolor  0.44520784 1.5310516\nSpeciesvirginica   0.46412393 2.0110518\n\n[[4]]\n                       2.5 %      97.5 %\n(Intercept)        1.6182321  2.72430044\nPetal.Width       -0.6140049 -0.01630542\nPetal.Length       0.6937939  0.96469395\nSepal.Width        0.3257653  0.66601260\nSpeciesversicolor -1.1982739 -0.24885002\nSpeciesvirginica  -1.6831329 -0.36386273\n\npar(mfrow = c(2, 2))\nmap(fits, pluck, \"residuals\") |&gt;\n  set_names(c(\"fit1\",\"fit2\", \"fit3\", \"fit4\")) |&gt;\n  walk(hist)\n\n\n\n\n\n\n\nmap(fits, pluck, \"residuals\") |&gt;\n  set_names(c(\"fit1\",\"fit2\", \"fit3\", \"fit4\")) |&gt;\n  iwalk(\\(x,idx) hist(x, main = idx))"
  }
]